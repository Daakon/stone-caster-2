# Prompt Assembler Documentation

## Overview

The Prompt Assembler is responsible for building the final prompt that will be sent to the AI model. It combines various prompt segments in a specific order to create a coherent, context-aware prompt.

## Assembly Order

The assembler builds prompts in the following order:

### Static Layers (Database-Driven)
These layers are stored as `prompt_segments` in the database and are fetched based on the current context:

1. **Core** - System-wide prompts available everywhere
2. **Ruleset** - Ruleset-specific prompts (multiple rulesets in configured order)
3. **World** - World-level prompts for all content in a world
4. **Entry** - Entry point main prompts
5. **Entry Start** - Entry point start prompts (first turn only)
6. **NPC** - NPC-specific prompts

### Dynamic Layers (Runtime-Generated)
These layers are generated dynamically at runtime and are not stored as segments:

7. **Game State** - Current game state information
8. **Player** - Player-specific information
9. **RNG** - Random number generation context
10. **Input** - Input processing context

## Key Principles

### Scope Restrictions
- Only 6 scopes are allowed for database segments: `core`, `ruleset`, `world`, `entry`, `entry_start`, `npc`
- Deprecated scopes (`game_state`, `player`, `rng`, `input`) are no longer supported
- Dynamic layers are generated by the system, not authored by users

### Assembly Process
1. **Static Layer Assembly**: Fetch and combine database segments in order
2. **Entry Start Handling**: Only include entry_start segments on the first turn
3. **NPC Block Building**: Combine NPC segments with tier-based selection
4. **Dynamic Layer Generation**: Append runtime-generated state blocks
5. **Budget Application**: Apply token limits and truncation policies

### Budget Management
- Static layers are prioritized (core/ruleset never dropped)
- Dynamic layers are last in truncation order (input first, then rng, player, game_state)
- NPC segments have separate budget allocation
- Token estimation and truncation policies ensure prompt fits within limits

## Database Schema

### prompt_segments Table
```sql
CREATE TABLE prompt_segments (
  id uuid PRIMARY KEY,
  scope text NOT NULL CHECK (scope IN ('core', 'ruleset', 'world', 'entry', 'entry_start', 'npc')),
  ref_id text,
  content text NOT NULL,
  metadata jsonb,
  version text,
  active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
```

### Scope Constraints
- `core`: No ref_id required
- `ruleset`: ref_id must reference a ruleset
- `world`: ref_id must reference a world
- `entry`: ref_id must reference an entry
- `entry_start`: ref_id must reference an entry
- `npc`: ref_id must reference an NPC

## API Usage

### Basic Assembly
```typescript
import { assemblePrompt } from '@/prompt/assembler/assembler';
import { SupabaseDbAdapter } from '@/prompt/assembler/db';

const args: AssembleArgs = {
  entryPointId: 'entry-123',
  worldId: 'world-456',
  isFirstTurn: true,
  tokenBudget: 4000,
  npcs: [{ id: 'npc-789', name: 'Gandalf' }]
};

const dbAdapter = new SupabaseDbAdapter(supabase);
const result = await assemblePrompt(args, dbAdapter);

console.log(result.prompt); // Final assembled prompt
console.log(result.meta.order); // Assembly order used
console.log(result.meta.segmentIdsByScope); // Segment IDs by scope
```

### Custom Database Adapter
```typescript
class CustomDbAdapter implements DbAdapter {
  async getSegments(scope: Scope, refId?: string): Promise<SegmentRow[]> {
    // Custom implementation
  }
  
  async getRulesetsForEntry(entryId: string): Promise<RulesetRow[]> {
    // Custom implementation
  }
  
  // ... other required methods
}
```

## Migration from Deprecated Scopes

### Deprecated Scopes
The following scopes are no longer supported:
- `game_state` - Use dynamic state generation instead
- `player` - Use dynamic player context instead  
- `rng` - Use dynamic RNG context instead
- `input` - Use dynamic input processing instead

### Migration Process
1. **Database Migration**: Existing segments with deprecated scopes are automatically deactivated
2. **Content Preservation**: Deprecated segments are marked with metadata for reference
3. **UI Updates**: Admin interface no longer allows creating/editing deprecated scopes
4. **Assembler Updates**: Dynamic layers are generated at runtime instead of fetched from database

### Content Migration
If you have content in deprecated scopes that you want to preserve:
1. Review the deactivated segments in the admin interface
2. Copy relevant content to appropriate allowed scopes
3. Update your prompt assembly logic to use the new structure

## Testing

### Unit Tests
- Scope validation tests ensure only allowed scopes are accepted
- Assembly order tests verify correct layer ordering
- Budget tests ensure proper token management

### Integration Tests
- End-to-end assembly tests with real database
- Performance tests for large prompt assemblies
- Budget constraint tests with various token limits

## Performance Considerations

### Database Queries
- Segments are fetched with proper indexing on scope and ref_id
- Multiple rulesets are fetched in a single query when possible
- NPC segments use tier-based selection for efficiency

### Memory Usage
- Large prompts are handled with streaming when possible
- Token estimation is cached for repeated assemblies
- Segment content is not duplicated unnecessarily

### Caching
- Static segments can be cached for repeated assemblies
- Dynamic layers are generated fresh each time
- Budget calculations are cached for similar configurations

## Troubleshooting

### Common Issues
1. **Scope Validation Errors**: Ensure you're using only allowed scopes
2. **Missing Segments**: Check that segments are active and properly referenced
3. **Token Budget Exceeded**: Adjust budget or implement better truncation
4. **Assembly Order Issues**: Verify that the order constant matches expected behavior

### Debug Information
The assembler provides detailed metadata for debugging:
- `segmentIdsByScope`: Which segments were included
- `order`: The assembly order used
- `tokensEstimated`: Token count before truncation
- `truncated`: Information about what was truncated

## Future Enhancements

### Planned Features
- Segment versioning and rollback
- Advanced caching strategies
- Real-time segment updates
- Custom assembly orders per entry type
- Segment dependency management

### Performance Improvements
- Parallel segment fetching
- Incremental assembly for large prompts
- Smart caching based on segment change frequency
- Compression for very large prompts