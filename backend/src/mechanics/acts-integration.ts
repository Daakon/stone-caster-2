/**
 * Acts Integration for Mechanics
 * Extends the acts system to support mechanics types
 */

import { skillCheckEngine, SkillCheckContext, SkillCheckResult } from './skill-checks.js';
import { conditionsEngine, StatusAction, StatusMap } from './conditions.js';
import { resourcesEngine, ResourceAction, ResourceMap } from './resources.js';

export interface MechanicsAct {
  type: 'CHECK_RESULT' | 'APPLY_STATUS' | 'REMOVE_STATUS' | 'TICK_STATUS' | 'RESOURCE_DELTA';
  [key: string]: any;
}

export interface MechanicsContext {
  sessionId: string;
  turnId: number;
  actor: string;
  target?: string;
  gameState: {
    resources: ResourceMap;
    status: StatusMap;
    flags: Record<string, any>;
    objectives: Record<string, string>;
  };
}

export class MechanicsActsIntegration {
  private readonly maxActsPerTurn: number;

  constructor() {
    this.maxActsPerTurn = parseInt(process.env.AWF_MECH_MAX_ACTS_PER_TURN || '8');
  }

  /**
   * Process mechanics acts in the interpreter
   */
  async processMechanicsActs(
    acts: MechanicsAct[],
    context: MechanicsContext
  ): Promise<{
    newActs: MechanicsAct[];
    updatedGameState: MechanicsContext['gameState'];
  }> {
    const newActs: MechanicsAct[] = [];
    const updatedGameState = { ...context.gameState };

    // Validate acts count
    if (acts.length > this.maxActsPerTurn) {
      throw new Error(`Too many mechanics acts: ${acts.length} > ${this.maxActsPerTurn}`);
    }

    // Process each act
    for (const act of acts) {
      const result = await this.processAct(act, context, updatedGameState);
      newActs.push(...result.newActs);
    }

    return { newActs, updatedGameState };
  }

  /**
   * Process a single mechanics act
   */
  private async processAct(
    act: MechanicsAct,
    context: MechanicsContext,
    gameState: MechanicsContext['gameState']
  ): Promise<{ newActs: MechanicsAct[] }> {
    const newActs: MechanicsAct[] = [];

    switch (act.type) {
      case 'CHECK_RESULT':
        // Skill check results are generated by the skill check engine
        // This is handled in the skill check engine itself
        break;

      case 'APPLY_STATUS':
        const applyActions = conditionsEngine.applyStatus(
          act.target || context.actor,
          act.key,
          act.stacks,
          act.duration,
          act.potency
        );
        newActs.push(...applyActions);
        break;

      case 'REMOVE_STATUS':
        const removeActions = conditionsEngine.removeStatus(
          act.target || context.actor,
          act.key
        );
        newActs.push(...removeActions);
        break;

      case 'TICK_STATUS':
        // Status ticking is handled by the conditions engine
        // This is called during TIME_ADVANCE processing
        break;

      case 'RESOURCE_DELTA':
        const resourceResult = resourcesEngine.applyResourceDelta(
          gameState.resources[act.key] || 0,
          act.key,
          act.delta,
          act.clamp
        );
        gameState.resources[act.key] = resourceResult.newValue;
        break;

      default:
        console.warn(`Unknown mechanics act type: ${act.type}`);
    }

    return { newActs };
  }

  /**
   * Generate skill check result act
   */
  generateSkillCheckAct(
    context: SkillCheckContext,
    result: SkillCheckResult
  ): MechanicsAct {
    return {
      type: 'CHECK_RESULT',
      id: result.id,
      skill: result.skill,
      roll: result.roll,
      total: result.total,
      threshold: result.threshold,
      outcome: result.outcome,
      margin: result.margin,
    };
  }

  /**
   * Generate status application act
   */
  generateApplyStatusAct(
    target: string,
    conditionId: string,
    stacks: number = 1,
    duration: number = -1,
    potency?: number
  ): MechanicsAct {
    return {
      type: 'APPLY_STATUS',
      target,
      key: conditionId,
      stacks,
      duration,
      potency,
    };
  }

  /**
   * Generate status removal act
   */
  generateRemoveStatusAct(target: string, conditionId: string): MechanicsAct {
    return {
      type: 'REMOVE_STATUS',
      target,
      key: conditionId,
    };
  }

  /**
   * Generate resource delta act
   */
  generateResourceDeltaAct(
    resourceId: string,
    delta: number,
    clamp: 'soft' | 'hard' = 'soft'
  ): MechanicsAct {
    return {
      type: 'RESOURCE_DELTA',
      key: resourceId,
      delta,
      clamp,
    };
  }

  /**
   * Process TIME_ADVANCE for status ticking and resource curves
   */
  processTimeAdvance(gameState: MechanicsContext['gameState']): MechanicsAct[] {
    const acts: MechanicsAct[] = [];

    // Process status ticking
    const statusActions = conditionsEngine.tickStatuses(gameState.status);
    acts.push(...statusActions);

    // Process resource curves
    const resourceActions = resourcesEngine.processResourceCurves(gameState.resources);
    acts.push(...resourceActions);

    return acts;
  }

  /**
   * Validate mechanics acts
   */
  validateMechanicsActs(acts: MechanicsAct[]): {
    valid: boolean;
    errors: string[];
  } {
    const errors: string[] = [];

    for (const act of acts) {
      switch (act.type) {
        case 'CHECK_RESULT':
          if (!act.id || !act.skill || typeof act.roll !== 'number') {
            errors.push('CHECK_RESULT act missing required fields');
          }
          break;

        case 'APPLY_STATUS':
          if (!act.target || !act.key) {
            errors.push('APPLY_STATUS act missing target or key');
          }
          break;

        case 'REMOVE_STATUS':
          if (!act.target || !act.key) {
            errors.push('REMOVE_STATUS act missing target or key');
          }
          break;

        case 'TICK_STATUS':
          if (!act.target || !act.key) {
            errors.push('TICK_STATUS act missing target or key');
          }
          break;

        case 'RESOURCE_DELTA':
          if (!act.key || typeof act.delta !== 'number') {
            errors.push('RESOURCE_DELTA act missing key or delta');
          }
          break;

        default:
          errors.push(`Unknown mechanics act type: ${act.type}`);
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    };
  }

  /**
   * Get mechanics act types
   */
  getMechanicsActTypes(): string[] {
    return [
      'CHECK_RESULT',
      'APPLY_STATUS',
      'REMOVE_STATUS',
      'TICK_STATUS',
      'RESOURCE_DELTA',
    ];
  }
}

// Singleton instance
export const mechanicsActsIntegration = new MechanicsActsIntegration();


