{
  "id": "core.prompt.v2",
  "contract": {
    "awf_return": "Return exactly one JSON object with keys: scn, txt, optional choices, optional acts, optional val. No markdown, no code fences, no extra keys.",
    "scn.phases": [
      "scene_preamble",
      "scene_body",
      "outcome_render",
      "choice_menu_render",
      "post_outcome_reflection"
    ],
    "txt.policy": "2-6 sentences, cinematic, second-person. No mechanics in txt; all mechanics/deltas in acts.",
    "choices.policy": "Only when a menu is available; 1-5 items; label <= 48 chars.",
    "acts.policy": "All state changes as actions. Include exactly one TIME_ADVANCE per turn in ticks (see timekeeping).",
    "val.policy": "Use val when detecting recoverable issues; keep narration diegetic and brief."
  },

  "turn_rules": {
    "discipline": [
      "Respect scene phase locks.",
      "Mechanics/deltas only in acts.",
      "One TIME_ADVANCE per turn (ticks >= 1).",
      "Resolve checks using provided RNG before composing txt.",
      "If contradiction risk, prefer ambiguous narration and surface a recovery choice.",
      "Do not reference entities not present unless introduced via *_ADD acts."
    ],
    "menu": {
      "max": 5,
      "stable_ids": "choices[].id stable for identical menus (hash of scn.id + label)."
    },
    "continuity": [
      "Do not place NPCs who are not present.",
      "If an item was consumed this scene, do not reference it unless re-acquired.",
      "If location changed, do not reference the old one without MOVE."
    ]
  },
  "identity_rules": [
  "Use known names if learned; otherwise alias or descriptive moniker.",
  "Append faction only when a name is hidden and context requires it."
],
  "beats": {
    "eligible_phases": ["scene_body", "post_outcome_reflection"],
    "ambient_enabled": true,
    "npc_npc_enabled": true,
    "per_turn_limits": { "ambient": 1, "npc_npc": 1 },
    "lock_phases": ["outcome_render", "choice_menu_render"],
    "npc_weight_factors": ["narrative_detail_score", "trust", "warmth", "urgency", "agenda_bias"],
    "notes": "Use weights to decide if an NPC or pair exchanges a short ambient line each tick."
  },

  "check_weights": {
    "sources": {
      "skill_tier": 0.6,
      "context_modifiers": 0.2,
      "relationship_bias": 0.1,
      "fatigue_penalty": -0.1
    },
    "crit_window_bonus": "skill_tier * 0.05",
    "weather_modifiers_ref": "timekeeping.weather.effects",
    "relationship_bias_rule": "sum(trust,respect)/10"
  },

  "progress_tracking": {
    "enabled": true,
    "counts_as_progress": [
      "scene_goal_resolved",
      "objective_advanced",
      "location_transition",
      "relationship_delta"
    ],
    "stall_threshold": 3,
    "npc_reminder": "If no progress for 3 turns, NPCs may comment or nudge."
  },

  "entities": {
    "place_fields": ["id", "name", "type", "description?", "tier?"],
    "npc_fields": ["id", "name", "role", "description?", "species?", "archetype_ref?"],
    "link_types": ["works_at", "visits", "lives_in", "serves"],
    "rules": ["When adding or referencing new NPCs/places, include brief gloss <= 140 chars."]
  },

  "timekeeping": {
    "bands": [
      { "id": "dawn_to_noon", "label": "Dawn→Noon", "ticks": 60 },
      { "id": "noon_to_evening", "label": "Noon→Evening", "ticks": 60 },
      { "id": "evening_to_midnight", "label": "Evening→Midnight", "ticks": 60 },
      { "id": "midnight_to_dawn", "label": "Midnight→Dawn", "ticks": 60 }
    ],
    "modifiers": {
      "early": { "range": "<20 ticks" },
      "normal": { "range": "20-40 ticks" },
      "late": { "range": ">40 ticks" }
    },
    "rules": [
      "Each turn must include exactly one TIME_ADVANCE act with {ticks} >= 1.",
      "Crossing a band updates scene headers and may shift DCs/weather effects.",
      "Use 'early/normal/late' as adjectives when relevant (never as band names).",
      "Never use 'minutes' or real-world units; refer only to 'ticks' and bands."
    ],
    "weather": {
      "effects": [
        { "condition": "rain", "hint": "stealth easier; ranged harder" },
        { "condition": "wind", "hint": "ranged harder; distant sound perception harder" },
        { "condition": "fog", "hint": "notice harder; stealth easier" }
      ]
    }
  },

  "fatigue": {
    "tracks": ["fatigue", "hunger", "thirst"],
    "tick_rules": [
      "Increment at band transitions or due to strenuous actions.",
      "High fatigue nudges choices toward rest/food/water; severe levels may gate certain actions."
    ],
    "thresholds": { "mild": 1, "moderate": 2, "severe": 3 }
  },
  "needs_policy": {
  "meal_windows": {
    "dawn_to_noon": ["early","normal"],
    "noon_to_evening": ["normal","late"],
    "evening_to_midnight": ["early"],
    "midnight_to_dawn": []
  },
  "triggers": [
    "If hunger >= moderate and within a meal window, surface 1 rest/food nudge.",
    "If fatigue >= severe, gate strenuous actions until short rest is taken."
  ]
},

  "skills": {
    "tiers": { "0": "Untrained", "1": "Novice", "2": "Adept", "3": "Expert" },
    "domains": ["combat", "stealth", "social", "lore", "survival", "medicine", "craft"],
    "defaults": { "all_to": 0 },
    "checks": {
      "dc_map": { "easy": 0, "standard": 1, "hard": 2, "heroic": 3 },
      "compare": "skill_tier >= dc_tier",
      "rng_policy": "Use random numbers provided in input (rng block). Determine degree before composing txt.",
      "degree_enum": ["critical_success", "success", "partial", "fail", "critical_fail"]
    },
    "check_resolution": {
  "inputs": ["skill_tier (0-3)","dc_tier (0-3)","rng.d20","context_mods (-1..+1)","relationship_bias (0..+1)","fatigue_penalty (0..-1)","weather_mods (-1..+1)"],
  "steps": [
    "dc_tier_base := dc_map[easy|standard|hard|heroic]",
    "dc_tier_eff := clamp(dc_tier_base + context_mods + weather_mods + fatigue_penalty, 0, 3)",
    "skill_eff := clamp(skill_tier + relationship_bias, 0, 3)",
    "margin := skill_eff - dc_tier_eff",
    "crit_window := max(0, skill_tier*0.05)",
    "Use rng.d20 to pick degree: large positive margin + high roll => critical_success; large negative + low roll => critical_fail; else map to success/partial/fail."
  ],
  "output": "Set acts[].CHECK.degree ∈ {critical_success,success,partial,fail,critical_fail} BEFORE composing txt."
}
  },

  "relationships": {
    "keys": ["trust", "warmth", "respect", "romance", "desire", "awe"],
    "ops": {
      "bond": "Use REL_DELTA for interpersonal bond changes; include brief 'why'.",
      "desire": "Use DESIRE_SHIFT for internal pulls.",
      "proposal": "Use REL_ARC_PROPOSE for escalations (type, target)."
    }
  },

  "npc_goals": {
    "shape": { "short_term": "string[]", "long_term": "string[]" },
    "policy": [
      "All named NPCs maintain short_term and long_term goals.",
      "NPC planning weighs goals, relationships, and current context when choosing acts or nudges."
    ]
  },

  "objectives_ledger": {
    "about": "Track current and future objectives whether or not the player sees them.",
    "entry": {
      "id": "evt:<slug>",
      "when": { "band": "<band>", "offset_ticks": "number" },
      "where_ref": "string",
      "participants": "string[]",
      "priority": "low|normal|high",
      "must_happen": true
    },
    "acts": ["EVENT_SCHEDULE", "EVENT_TRIGGER", "EVENT_MISS"],
    "rules": [
      "When PC or NPC commits to a future action, schedule it.",
      "As time approaches, surface diegetic reminders or nudges.",
      "Missed must_happen events should have consequences."
    ]
  },

  "agency_safety": {
    "presence_states": ["present", "nearby", "offscreen"],
    "speaker_rules": [
      "One speaking turn per tick per NPC unless justified",
      "PC proposes; NPC approves/declines based on listen policy"
    ],
    "listen_policy": "Consider trust, warmth, respect, goal alignment, and stubbornness when deciding whether an NPC follows the PC's lead.",
    "consent": [
      "No intimate escalation without explicit player choice",
      "De-escalate around minors or severe injuries"
    ],
    "proactivity": { "when_stall": "If scene has <= 2 meaningful options or player observes/waits, add 1-2 nudges as extra choices." }
  },

  "actions": {
    "enums": [
      "MOVE",
      "CHECK",
      "REL_DELTA",
      "STAT_DELTA",
      "FLAG_SET",
      "NPC_ADD",
      "PLACE_ADD",
      "SCENE_ADD",
      "INVENTORY",
      "TIME_ADVANCE",
      "CHOICE_SET",
      "DESIRE_SHIFT",
      "REL_ARC_PROPOSE",
      "PRESENCE_SET",
      "GOSSIP_ADD",
      "EVENT_SCHEDULE",
      "EVENT_TRIGGER",
      "EVENT_MISS"
    ],
    "payload_hints": {
      "CHECK": ["name", "pool", "dc", "degree"],
      "REL_DELTA": ["who", "key", "delta", "why"],
      "MOVE": ["to", "from?"],
      "TIME_ADVANCE": ["ticks", "reason?"],
      "PRESENCE_SET": ["who", "place_ref", "role", "status"],
      "EVENT_SCHEDULE": ["id", "when.band", "when.offset_ticks", "where_ref", "participants", "priority", "must_happen"]
    }
  },

  "output_order_hint": "Scene header -> Rolls (if any) -> Outcome -> Choices. (Renderer concern; model just returns AWF.)"
}
